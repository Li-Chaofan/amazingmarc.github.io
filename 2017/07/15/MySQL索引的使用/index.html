<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java, Meituan" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="概述在了解B+树索引的本质和实现后，下一个需要考虑的问题是怎样正确地使用B+树索引，这不是一个简单的问题。这里总结的可能并不适用与所有的应用场合。我所能做的只是概括一个大概的方向。在实际应用中，每个开发人员还是需要根据自己的具体生成环境来使用索引，并观察索引使用的情况，判断是否需要添加索引。不要盲从任何人给你的经验意见，Think Different。
注意 本文是建立在  MySQL索引 篇文章">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL索引的使用">
<meta property="og:url" content="http://yoursite.com/2017/07/15/MySQL索引的使用/index.html">
<meta property="og:site_name" content="LiChaofan">
<meta property="og:description" content="概述在了解B+树索引的本质和实现后，下一个需要考虑的问题是怎样正确地使用B+树索引，这不是一个简单的问题。这里总结的可能并不适用与所有的应用场合。我所能做的只是概括一个大概的方向。在实际应用中，每个开发人员还是需要根据自己的具体生成环境来使用索引，并观察索引使用的情况，判断是否需要添加索引。不要盲从任何人给你的经验意见，Think Different。
注意 本文是建立在  MySQL索引 篇文章">
<meta property="og:image" content="http://yoursite.com/upload/index_user_demo1.png">
<meta property="og:image" content="http://yoursite.com/upload/index_user_demo2.png">
<meta property="og:updated_time" content="2018-07-15T12:33:34.745Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL索引的使用">
<meta name="twitter:description" content="概述在了解B+树索引的本质和实现后，下一个需要考虑的问题是怎样正确地使用B+树索引，这不是一个简单的问题。这里总结的可能并不适用与所有的应用场合。我所能做的只是概括一个大概的方向。在实际应用中，每个开发人员还是需要根据自己的具体生成环境来使用索引，并观察索引使用的情况，判断是否需要添加索引。不要盲从任何人给你的经验意见，Think Different。
注意 本文是建立在  MySQL索引 篇文章">
<meta name="twitter:image" content="http://yoursite.com/upload/index_user_demo1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/15/MySQL索引的使用/"/>





  <title> MySQL索引的使用 | LiChaofan </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LiChaofan</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/15/MySQL索引的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="marc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/lufei.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiChaofan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                MySQL索引的使用
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-15T16:59:00+08:00">
                2017-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/InnoDB/" itemprop="url" rel="index">
                    <span itemprop="name">InnoDB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在了解B+树索引的本质和实现后，下一个需要考虑的问题是怎样正确地使用B+树索引，这不是一个简单的问题。这里总结的可能并不适用与所有的应用场合。我所能做的只是概括一个大概的方向。在实际应用中，每个开发人员还是需要根据自己的具体生成环境来使用索引，并观察索引使用的情况，判断是否需要添加索引。不要盲从任何人给你的经验意见，Think Different。</p>
<p><strong>注意</strong> 本文是建立在  <a href="/2017/07/14/MySQL索引/" title="MySQL索引">MySQL索引</a> 篇文章的基础上的。</p>
<a id="more"></a>
<h1 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h1><p>虽然索引是个好东西，但是不能乱建，在介绍如何更好的使用索引之前先要了解一下使用这玩意儿的代价，它在空间和时间上都会拖后腿：</p>
<ol>
<li>空间上的代价：这个是显而易见的，每建立一个索引都为要它建立一棵B+树，B+树的每一个节点都是一个数据页，一个页可是要占用16KB的存储空间的，一棵很大的B+树由许多数据页组成，那可是很大的一片存储空间呢。</li>
<li>时间上的代价: 我们讲过，每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。在对表中数据进行增、删、改操作的时候可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，这还能不给性能拖后腿么？</li>
</ol>
<h1 id="B-树索引的适用条件"><a href="#B-树索引的适用条件" class="headerlink" title="B+ 树索引的适用条件"></a>B+ 树索引的适用条件</h1><p>首先我们先建立一张表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</div><div class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    birthday <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    phone_number <span class="built_in">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    country <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    <span class="keyword">KEY</span> idx_name_age_birthday (<span class="keyword">name</span>, birthday, phone_number)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>对于这个person_info表我们需要注意两点：</p>
<ol>
<li><p>我们并没有在表中定义主键，所以innoDB存储引擎会默认为我们的表添加一行row_id列作为主键。</p>
</li>
<li><p>重点注意我们定义的索引idx_name_age_birthday，它是由3个列组成的联合索引。所以在这个索引对应的B+树的叶子节点处存储的记录只保留name、birthday、phone_number这三个列的值以及主键值。</p>
</li>
</ol>
<p>下边我们画一下索引idx_name_age_birthday的示意图，不过既然我们已经掌握了InnoDB的B+树索引原理，那我们在画图的时候为了让图更加清晰，所以在记录结构中就省略一些不必要的部分，比如单链表的箭头、记录的主键值啥的，只保留name、birthday、phone_number这三个列的值，所以示意图就长这样（留心的同学看出来了，这其实和《高性能MySQL》里举的例子的图差不多，我觉得这个例子特别好，所以就借鉴了一下）：</p>
<p><img src="/upload/index_user_demo1.png" alt="avatar"></p>
<p>为了方便大家理解，我们特意用不同颜色区分了一下内节点和叶子节点。并且用不同颜色区分了一下内节点中的目录项记录和叶子节点中的用户记录（由于不是聚簇索引，所以用户记录是不完整的，缺少country列的值）。从图中可以看出，这个idx_name_age_birthday索引对应的B+树中节点和记录的排序方式就是这样的：</p>
<ol>
<li>先按照name列的值进行排序。</li>
<li>如果name列的值相同，则按照birthday列的值进行排序。</li>
<li>如果birthday列的值也相同，则按照phone_number的值进行排序。</li>
</ol>
<p>这个排序方式十分、特别、非常、巨、very very very重要，因为当且仅当节点和记录是排好序的，我们才可以通过二分法来快速定位查找。下边的内容都仰仗这个图了，大家对照着图理解。</p>
<h2 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h2><p>如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span> <span class="keyword">AND</span> birthday = <span class="string">'1990-09-27'</span> <span class="keyword">AND</span> phone_number = <span class="string">'15123983239'</span>;</div></pre></td></tr></table></figure>
<p>我们建立的idx_name_age_birthday索引包含的3个列在这个查询语句中都展现出来了，而且搜索条件中列的顺序和定义索引列时的顺序是一致的。大家可以想象一下这个查询过程：</p>
<ul>
<li><p>因为B+树的数据页和记录先是按照name列的值进行排序的，所以可以很快定位name列的值是Ashburn的记录位置。</p>
</li>
<li><p>在name列相同的记录里又是按照birthday列的值进行排序的，所以在name列的值是Ashburn的记录里又可以快速定位birthday列的值是’1990-09-27’的记录。</p>
</li>
<li><p>如果很不幸，name和birthday列的值都是相同的，那记录是按照phone_number列的值排序的，所以联合索引中的三个列都可能被用到。</p>
</li>
</ul>
<h2 id="匹配左边的列"><a href="#匹配左边的列" class="headerlink" title="匹配左边的列"></a>匹配左边的列</h2><p>其实在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span> <span class="keyword">AND</span> birthday = <span class="string">'1990-09-27'</span>;</div></pre></td></tr></table></figure>
<p>这两个语句都可以走我们刚才创建的那个B+树。但是下面的语句则不能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM person_info WHERE birthday = &apos;1990-09-27&apos;;</div></pre></td></tr></table></figure>
<p>因为B+树的数据页和记录先是按照name列的值排序的，你直接根据birthday的值去查找，是无法在B+树上进行查找的。</p>
<p>但是需要特别注意的一点是，搜索条件中的列的顺序必须和索引列的定义顺序一致，比方说索引列的定义顺序是name、birthday、phone_number，如果我们的搜索条件中只有name和phone_number，而没有birthday，这样只能用到name列的索引，birthday和phone_number的索引就用不上了（因为name值相同的记录先按照birthday进行排序，birthday值相同的记录才按照phone_number值进行排序）。</p>
<h2 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h2><p>对于字符串类型的索引列来说，我们没必要对该列的值进行精确匹配，只匹配它的前缀也是可以的，因为前缀本身就已经是排好序的。比方说我们想查询名字以’As’开头的记录，那就可以这么写查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'As%'</span>;</div></pre></td></tr></table></figure>
<p>B+树中的数据页和记录都先是按照name列排序的，只给出前缀也是可以通过二分法快速定位的。但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%As%'</span>;</div></pre></td></tr></table></figure>
<p>MySQL就无法通过二分法来快速定位记录位置了，因为字符串中间有’As’的字符串并没有排好序，所以只能全表扫描了。</p>
<h2 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h2><p>回头看我们idx_name_age_birthday索引的B+树示意图，所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> &gt; <span class="string">'Asa'</span> <span class="keyword">AND</span> <span class="keyword">name</span> &lt; <span class="string">'Barlow'</span>;</div></pre></td></tr></table></figure>
<p>由于B+树中的节点和数据页是先按name列排序的，所以我们上边的查询过程其实是这样的：</p>
<ol>
<li>找到name值为Asa的记录。</li>
<li>找到name值为Barlow的记录。</li>
<li>由于所有记录都是由连链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来了<br>找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。</li>
</ol>
<p>不过进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引，比方说这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> &gt; <span class="string">'Asa'</span> <span class="keyword">AND</span> <span class="keyword">name</span> &lt; <span class="string">'Barlow'</span> <span class="keyword">AND</span> birthday &gt; <span class="string">'1980-01-01'</span>;</div></pre></td></tr></table></figure>
<p>为啥不能呢？因为上边这个查询可以分成两个部分：</p>
<ol>
<li><p>通过条件name &gt; ‘Asa’ AND name &lt; ‘Barlow’来对name进行范围，查找的结果可能有多条name值不同的记录，</p>
</li>
<li><p>对这些name值不同的记录继续通过birthday &gt; ‘1980-01-01’条件继续过滤。</p>
</li>
</ol>
<p>但是值得注意的是，只有name值相同的情况下才能用birthday列的值进行排序，也就是说通过name进行范围查找的结果并不是按照birthday列进行排序的，所以在搜索条件中继续以birthday列进行查找时是用不到B+树索引的。</p>
<p><strong>注意</strong>：当使用辅助索引进行范围查找时（而且辅助索引不能覆盖我们要查询的信息），如果访问的数据占整张表数据蛮大的一部分（一般是20%）,优化器会选择通过聚集索引来查找数据（全表扫描）。因为通过辅助索引查询到指定数据后还需要进行回表来查找我们需要的数据列数据。虽然辅助索引中数据是顺序存放的，但是在进行一次聚集索引的查找时，查找的数据则是无序的。因此变成了磁盘上的离散读操作。而这种情况不如直接全表扫描进行顺序读。这是由当前传统机械硬盘的特性决定的，即利用顺序读来替换随机读的查找。若用户使用的磁盘是固态硬盘，随机读操作非常快，同时拥有足够的自信来确认使用辅助索引可以带来更好的性能，那么可以使用关键字 FORCE INDEX来强制使用某个索引。</p>
<h2 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h2><p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说这样:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span> <span class="keyword">AND</span> birthday &gt; <span class="string">'1980-01-01'</span> <span class="keyword">AND</span> birthday &lt; <span class="string">'2000-12-31'</span> <span class="keyword">AND</span> phone_number &gt; <span class="string">'15100000000'</span>;</div></pre></td></tr></table></figure>
<p>这个查询的条件可以分为3个部分：</p>
<ol>
<li><p>name = ‘Ashburn’，对name列进行精确查找，当然可以使用B+树索引了。</p>
</li>
<li><p>birthday &gt; ‘1980-01-01’ AND birthday &lt; ‘2000-12-31’，由于name列是精确查找，所以通过name = ‘Ashburn’条件查找后得到的结果的name值都是相同的，它们会再按照birthday的值进行排序。所以此时对birthday列进行范围查找是可以用到B+树索引的。</p>
</li>
<li><p>phone_number &gt; ‘15100000000’，通过birthday的范围查找的记录的birthday的值可能不同，所以这个条件无法再利用B+树索引了，只能遍历上一步查询得到的记录。</p>
</li>
</ol>
<p>说一句“题外话”，如果在表中还有一个单独的按照name列的索引，那么下面的查询语句会使用哪个索引呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span></div></pre></td></tr></table></figure>
<p>理论上可以使用的索引有两个，一个是单独的以name列简历的索引，还有一个就是联合索引，最终MySQL会使用单独name列创建的索引，因为该索引的叶子节点上只包含单个name-主键的键值对，所以一个页存放的记录应该更多。</p>
<h2 id="用于排序"><a href="#用于排序" class="headerlink" title="用于排序"></a>用于排序</h2><p>我们在写查询语句的时候经常需要对查询出来的记录按照某种规则进行排序，对于不适用B+树索引进行排序的情况，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序、吧啦吧啦排序等等在内存中对这些记录进行排序，然后再把排好序的结果集返回到客户端。但是如果ORDER BY子句里使用到了我们的索引列，就有可能省去在内存中排序的步骤，比如下边这个简单的查询语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;</div></pre></td></tr></table></figure>
<p>这个查询的结果集需要先按照name值排序，如果记录的name值相同，则需要按照birthday来排序，如果birthday的值相同，则需要按照phone_number排序。大家可以回过头去看我们建立的idx_name_age_birthday索引的示意图，因为这个B+树索引本身就是排好序的，所以直接从索引中提取数据就好了.</p>
<p>但是有个问题需要注意，ORDER BY的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出ORDER BY phone_number, birthday, name的顺序，那也是用不了B+树索引，这种颠倒顺序就不能使用索引的原因我们上边详细说过了，这就不赘述了。同理，ORDER BY name、ORDER BY name, birthday这种匹配索引左边的列的形式可以使用部分的B+树索引。</p>
<h2 id="用于分组"><a href="#用于分组" class="headerlink" title="用于分组"></a>用于分组</h2><p>有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number</div></pre></td></tr></table></figure></p>
<p>这个查询语句相当于做了3次分组操作：</p>
<ol>
<li><p>先把记录按照name值进行分组，所有name值相同的记录划分为一组。</p>
</li>
<li><p>将每个name值相同的分组里的记录再按照birthday的值进行分组，将birthday值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。</p>
</li>
<li><p>再将上一步中产生的小分组按照phone_number的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把大分组分成若干个小分组，然后把若干个小分组再细分成更多的小小分组。</p>
</li>
</ol>
<p>然后针对那些小小分组进行统计，比如在我们这个查询语句中就是统计每个小小分组包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的B+树中的索引列的顺序是一致的，而我们的B+树索引又是按照索引列排好序的，这不正好么，所以可以直接使用B+树索引进行分组。</p>
<p>和使用B+树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组.</p>
<h1 id="如何挑选索引"><a href="#如何挑选索引" class="headerlink" title="如何挑选索引"></a>如何挑选索引</h1><p>上边我们以idx_name_age_birthday索引为例对索引的适用条件进行了详细的介绍，下边看一下我们在建立索引时或者编写查询语句时就应该注意的一些事项。</p>
<h2 id="只为用于搜索、排序或分组的列创建索引"><a href="#只为用于搜索、排序或分组的列创建索引" class="headerlink" title="只为用于搜索、排序或分组的列创建索引"></a>只为用于搜索、排序或分组的列创建索引</h2><p>也就是说，只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT birthday, country FROM person_name WHERE name = &apos;Ashburn&apos;;</div></pre></td></tr></table></figure>
<p>像查询列表中的birthday、country这两个列就不需要建立索引，我们只需要为出现在WHERE子句中的name列创建索引就可以了。</p>
<h2 id="考虑列的基数"><a href="#考虑列的基数" class="headerlink" title="考虑列的基数"></a>考虑列的基数</h2><p>列的基数指的是某一列中不重复数据的个数，比方说某个列包含值2, 5, 8, 2, 5, 8, 2, 5, 8，虽然有9条记录，但该列的基数却是3。也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。假设某个列的基数为1，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行二分法查找了～ 所以结论就是：最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</p>
<h2 id="索引列的类型尽量小"><a href="#索引列的类型尽量小" class="headerlink" title="索引列的类型尽量小"></a>索引列的类型尽量小</h2><p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有TINYINT、MEDIUMINT、INT、BIGINT这么几种，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增，我们这里所说的类型大小指的就是该类型表示的数据范围的大小。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用INT就不要使用BIGINT，能使用MEDIUMINT就不要使用INT～ 这是因为：</p>
<ul>
<li>数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）</li>
<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。<br>这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的叶子节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间。</li>
</ul>
<h2 id="索引字符串值的前缀"><a href="#索引字符串值的前缀" class="headerlink" title="索引字符串值的前缀"></a>索引字符串值的前缀</h2><p>我们知道一个字符串其实是由若干个字符组成，如果我们在MySQL中适用utf8字符集去存储字符串的话，编码一个字符需要占用1~3个字节。假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题：</p>
<ol>
<li>B+树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。</li>
<li>如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li>
</ol>
<p>所以索引的设计者提出了个方案 — 只对字符串的前几个字符进行索引。通过字符串的前几个字符我们已经能大概排序字符串了，剩下不能排序的可以通过遍历进行查找啊，这样只在B+树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题，何乐而不为，比方说我们在建表语句中只对name列的前10个字符进行索引可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE person_info(</div><div class="line">    name VARCHAR(100) NOT NULL,</div><div class="line">    birthday DATE NOT NULL,</div><div class="line">    phone_number CHAR(11) NOT NULL,</div><div class="line">    country varchar(100) NOT NULL,</div><div class="line">    KEY idx_name_age_birthday (name(10), birthday, phone_number)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>name(10)就表示在建立的B+树索引中只保留记录的前10个字符的编码，这种只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。</p>
<h2 id="尽量使用联合索引"><a href="#尽量使用联合索引" class="headerlink" title="尽量使用联合索引"></a>尽量使用联合索引</h2><p>如果我们的搜索条件中有多个列的话，最好为这些列建立一个联合索引， 而不是分别为每个列建立一个索引（因为每建一个索引都会维护一棵B+树），就像我们person_info表的idx_name_age_birthday索引，它是name、 birthday、 phone_number这三个列的联合索引，所以这个联合索引可以用于搜索下边几种列组合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name, birthday, phone_number</div><div class="line">name, birthday</div><div class="line">name</div></pre></td></tr></table></figure>
<p>如果我们的确有对其他列搜索的需求，那就为其他列单独再建一个索引吧，虽然创建索引是有代价的，但是还是要保证高效的查询比较重要。</p>
<h2 id="让索引列在比较表达式中单独出现"><a href="#让索引列在比较表达式中单独出现" class="headerlink" title="让索引列在比较表达式中单独出现"></a>让索引列在比较表达式中单独出现</h2><p>假设表中有一个整数列my_col，我们为这个列建立了索引。下边的两个WHERE子句虽然语义是一致的，但是在效率上却有差别：</p>
<ol>
<li><p>WHERE my_col * 2 &lt; 4</p>
</li>
<li><p>WHERE my_col &lt; 4/2</p>
</li>
</ol>
<p>第1个WHERE子句中my_col列并不是以单独列的形式出现的，而是以my_col * 2这样的表达式的形式出现的，存储引擎会依次遍历所有的记录，计算这个表达式的值是不是小于4，所以这种情况下是使用不到为my_col列建立的B+树索引的。而第2个WHERE子句中my_col列并是以单独列的形式出现的，这样的情况可以直接使用B+树索引。</p>
<p>所以结论就是：如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</p>
<h2 id="主键插入顺序"><a href="#主键插入顺序" class="headerlink" title="主键插入顺序"></a>主键插入顺序</h2><p>我们知道，对于一个使用InnoDB存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，这就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在1~100之间：<br>如果此时再插入一条主键值为9的记录，那它插入的位置就如下图：<br><img src="/upload/index_user_demo2.png" alt="avatar"></p>
<p>可这个数据页已经满了啊，再插进来咋办呢？我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：性能损耗！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议：让主键具有AUTO_INCREMENT，让存储引擎自己为表生成主键，而不是我们手动插入.</p>
<h2 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h2><p>有时候有的同学有意或者无意的就对同一个列创建了多个索引，比方说这样写建表语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    birthday <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    phone_number <span class="built_in">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    country <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</div><div class="line">    <span class="keyword">KEY</span> idx_name_age_birthday (<span class="keyword">name</span>(<span class="number">10</span>), birthday, phone_number),</div><div class="line">    <span class="keyword">KEY</span> idx_name (<span class="keyword">name</span>(<span class="number">10</span>))</div><div class="line">);</div></pre></td></tr></table></figure>
<p>我们知道，通过idx_name_age_birthday索引就可以对name列进行快速搜索，再创建一个专门针对name列的索引就算是一个冗余索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p>
<p>另一种情况，我们可能会对某个列重复建立索引，比方说这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> repeat_index_demo (</div><div class="line">    c1 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</div><div class="line">    c2 <span class="built_in">INT</span>,</div><div class="line">    <span class="keyword">UNIQUE</span> uidx_c1 (c1),</div><div class="line">    <span class="keyword">INDEX</span> idx_c1 (c1)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>我们看到，c1既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p>
<h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>InnoDB支持覆盖索引（covering index, 或称索引覆盖），即从辅助索引中就可以得到查询的记录，而不是需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引。因此可以减少大量的IO操作。</p>
<p>比方说这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span>;</div></pre></td></tr></table></figure>
<p>erson_info表的idx_name_age_birthday的索引列只有3个，而表中一共有4个列，所以为了获得完整的用户记录，在通过idx_name_age_birthday索引得到对应的主键值后还得到聚簇索引中做一次回表操作。回表操作也是要性能损耗的啊，所以我们建议：最好在查询列表里只包含索引列，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, birthday, phone_number <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span>;</div></pre></td></tr></table></figure>
<p>因为我们只查询name, birthday, phone_number这三个索引列的值，所以在通过idx_name_age_birthday索引得到结果后就不必到聚簇索引中再查找记录的剩余列，也就是country列的值了。这样就省去了回表操作带来的性能损耗.</p>
<p>当然，如果业务需要查询出索引以外的列，那还是以保证业务需求为重。但是我们很不鼓励用*号作为查询列表，最好把我们需要查询的列依次标明。</p>
<p>覆盖索引的另外一个好处是对于统计问题而言的。比如下面的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> birthday &gt; <span class="string">'1980-01-01'</span> <span class="keyword">AND</span> birthday &lt; <span class="string">'2000-12-31'</span>;</div></pre></td></tr></table></figure>
<p>一般对于（name,birthday,phone_number）索引，这里只根据列birthday进行条件查询，一般情况下是不能使用该联合索引的，但是这条语句是统计操作，并且可以使用覆盖索引信息，因此优化器会选择该联合索引。</p>
<h1 id="索引提示"><a href="#索引提示" class="headerlink" title="索引提示"></a>索引提示</h1><p>MySQL数据库支持索引提示（INDEX HINT）,显示的告诉优化器使用哪个索引。总结以下两种情况可能需要到INDEX HINT:</p>
<ol>
<li>MySQL数据库的优化器错误的选择了某个索引，导致SQL语句运行的很慢，这种情况下很少见，优化器在绝大部分情况下工作的都非常有效和正确。</li>
<li>某SQL语句可以选择的索引非常多，这是优化器选择执行计划时间的开销可能会大于SQL语句本身。比如优化器分析Range查询本身就是比较耗时的操作。这是开发人员或者DBA分析最优的索引选择，通过INDEX HINT来强制使优化器不进行各个路径的成本分析，直接选择索引来完成查询。</li>
</ol>
<p>但是需要注意的是，USE INDEX 只是告诉优化器可以选择该索引，实际上优化器还是会根据自己的判断进行选择。而如果使用 FORCE INDEX的话，那么优化器选择的索引就和指定的索引是一致的。所以如果用户确定指定某个索引来完成查询，那么最可靠的是使用FORCE INDEX，而不是使用USE INDEX .</p>
<h1 id="Multi-Range-Read-优化"><a href="#Multi-Range-Read-优化" class="headerlink" title="Multi-Range Read 优化"></a>Multi-Range Read 优化</h1><p>MySQL5.6版本开始开始支持MRR优化。MRR优化的目的就是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，这对于IO-bound类型的SQL查询语句可带来极大的性能提升。MRR有以下几个好处：</p>
<ol>
<li>MRR使数据访问变得较为顺序，在查询辅助索引时，首先根据得到的查询结构，按照主键进行排序，并按照主键排序的顺序进行书签查找。</li>
<li>减少缓冲池中页被替换的次数。</li>
<li>批量处理对键值的操作。</li>
</ol>
<p>MRR工作方式如下：</p>
<ol>
<li>将查询得到的辅助索引键值放到一个缓存中，这是缓存中的数据是根据辅助索引键值排序的。</li>
<li>将缓存中的键值根据RowID进行排序。</li>
<li>根据RowID的排序顺序性来访问实际的数据文件。</li>
</ol>
<p>此外，若InnoDB的缓冲池不是足够大，即不能存放下一张表中所有的数据，此时频繁的离散度操作还会导致缓存中的页被替换出缓冲池，然后又被不断的读入缓冲池。或是按照主键顺序进行访问，则可以将此重复行为降为最低。</p>
<p>此外，MRR还可以将某些范围查询，拆分成键值对，以此来进行批量的数据查询。这样做的好处是在拆分过程中，直接过滤一些不符合查询条件的数据：例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM t </div><div class="line">	WHERE key_part1&gt;1000 AND key_part2&lt;2000</div><div class="line">	AND key_part2 = 10000;</div></pre></td></tr></table></figure>
<p>表t有（key_part1,key_part2）的联合索引，因此索引根据key_part1,key_part2的位置关系进行排序。若没有MRR，此时查询类型为Range,SQL优化器会先将key_part1大于1000并且小于2000的数据都取出，即使key_part2不等于10000.待取出行数据之后再根据key_part2的条件进行过滤，这会导致无用数据被取出。如果有大量无用数据，则启用MRR将会使性能有巨大提高。<br>倘若使用了MRR优化，优化器会先将查询条件进行拆分，然后再进行数据查询。拿上面这个查询语句来说，优化器会将查询条件拆分为（1000，10000），（1001，10000）…… （2000，10000）最后再根据拆分出的条件进行数据查询。</p>
<h1 id="Index-Condition-PushDown-ICP-优化"><a href="#Index-Condition-PushDown-ICP-优化" class="headerlink" title="Index Condition PushDown(ICP)优化"></a>Index Condition PushDown(ICP)优化</h1><p>和MRR一样，ICP同样是MySQL5.6开始支持的一种根据索引进行查询的优化方式。之前不支持ICP优化，当进行索引查询时，首先根据索引来查找记录，然后再根据WHERE条件来过滤记录。在支持ICP后，MySQL数据库会在取出索引的同时，判断是否可以进行WHERE条件的过滤，也就是将WHERE的部分过滤操作放在了存储引擎层。在某些查询下，可以大大减小上传SQL层对记录的索取，从而提升数据库的整体性能。<br>假设某张表含有联合索引（zip_code,last_name,first_name），并且查询语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> people</div><div class="line">	<span class="keyword">WHERE</span> zip_code=<span class="string">'95054'</span></div><div class="line">	<span class="keyword">AND</span> last_name <span class="keyword">LIKE</span> <span class="string">'%etrunia%'</span></div><div class="line">	<span class="keyword">AND</span> address <span class="keyword">LIKE</span> <span class="string">'%Main Street%'</span>;</div></pre></td></tr></table></figure>
<p>对于上述语句，MySQL数据库可以通过索引来定位zipcode等于95054的记录，但是索引对于WHERE 语句的后两个条件没有任何帮助。活不支持ICP优化，则数据库需要先通过索引取出所有zipcode=95054的记录，然后再过滤WHERE 之后的两个条件。<br>若支持ICP优化，则在索引取出的时候，就会进行WHERE条件的过滤，然后再获取记录，这将极大的提高查询效率。当然，WHERE可以过滤的条件是要 该索引可以覆盖的范围。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上边只是我们在创建和使用B+树索引的过程中需要注意的一些点，后边我们还会陆续介绍更多的优化方法和注意事项，敬请期待。本集内容总结如下：</p>
<ol>
<li>B+树索引在空间和时间上都有代价，所以没事儿别瞎建索引。</li>
<li><p>B+树索引适用于下边这些情况：</p>
<ul>
<li>全值匹配</li>
<li>匹配左边的列</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>用于排序</li>
<li>用于分组</li>
</ul>
</li>
<li><p>在使用索引时需要注意下边这些事项：</p>
<ul>
<li>只为用于搜索、排序或分组的列创建索引</li>
<li>为列的基数大的列创建索引</li>
<li>索引列的类型尽量小</li>
<li>可以只对字符串值的前缀建立索引</li>
<li>只有索引列在比较表达式中单独出现才可以适用索引</li>
<li>为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT属性。</li>
<li>定位并删除表中的重复和冗余索引</li>
</ul>
</li>
<li><p>此外我们还介绍了覆盖索引，MRR优化，ICP优化对索引的优化。</p>
</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/14/MySQL索引/" rel="next" title="MySQL索引">
                <i class="fa fa-chevron-left"></i> MySQL索引
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/lufei.jpg"
               alt="marc" />
          <p class="site-author-name" itemprop="name">marc</p>
           
              <p class="site-description motion-element" itemprop="description">Keep on going</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/amazingmarc" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://tech.meituan.com/" title="美团技术博客" target="_blank">美团技术博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://blog.csdn.net/v_JULY_v" title="v_JULY_v" target="_blank">v_JULY_v</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#索引的代价"><span class="nav-number">2.</span> <span class="nav-text">索引的代价</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-树索引的适用条件"><span class="nav-number">3.</span> <span class="nav-text">B+ 树索引的适用条件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#全值匹配"><span class="nav-number">3.1.</span> <span class="nav-text">全值匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匹配左边的列"><span class="nav-number">3.2.</span> <span class="nav-text">匹配左边的列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匹配列前缀"><span class="nav-number">3.3.</span> <span class="nav-text">匹配列前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匹配范围值"><span class="nav-number">3.4.</span> <span class="nav-text">匹配范围值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#精确匹配某一列并范围匹配另外一列"><span class="nav-number">3.5.</span> <span class="nav-text">精确匹配某一列并范围匹配另外一列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用于排序"><span class="nav-number">3.6.</span> <span class="nav-text">用于排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用于分组"><span class="nav-number">3.7.</span> <span class="nav-text">用于分组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何挑选索引"><span class="nav-number">4.</span> <span class="nav-text">如何挑选索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#只为用于搜索、排序或分组的列创建索引"><span class="nav-number">4.1.</span> <span class="nav-text">只为用于搜索、排序或分组的列创建索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#考虑列的基数"><span class="nav-number">4.2.</span> <span class="nav-text">考虑列的基数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引列的类型尽量小"><span class="nav-number">4.3.</span> <span class="nav-text">索引列的类型尽量小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引字符串值的前缀"><span class="nav-number">4.4.</span> <span class="nav-text">索引字符串值的前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尽量使用联合索引"><span class="nav-number">4.5.</span> <span class="nav-text">尽量使用联合索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#让索引列在比较表达式中单独出现"><span class="nav-number">4.6.</span> <span class="nav-text">让索引列在比较表达式中单独出现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主键插入顺序"><span class="nav-number">4.7.</span> <span class="nav-text">主键插入顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冗余和重复索引"><span class="nav-number">4.8.</span> <span class="nav-text">冗余和重复索引</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#覆盖索引"><span class="nav-number">5.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#索引提示"><span class="nav-number">6.</span> <span class="nav-text">索引提示</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Multi-Range-Read-优化"><span class="nav-number">7.</span> <span class="nav-text">Multi-Range Read 优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Index-Condition-PushDown-ICP-优化"><span class="nav-number">8.</span> <span class="nav-text">Index Condition PushDown(ICP)优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">9.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">marc</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
